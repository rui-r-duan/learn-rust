* rustup
#+begin_verse
  rustup update
  rustup doc --book
#+end_verse
* cargo
#+begin_verse
  cargo run
  cargo build --verbose
  cargo update
  RUST_BACKTRACE=1 cargo run --verbose
  RUST_BACKTRACE=full cargo run
  cargo doc          # calls rustdoc
  cargo doc --open
  cargo login [token]
  cargo publish
  cargo yank --vers 1.0.1
  cargo yank --vers 1.0.1 --undo
#+end_verse
* cargo test
#+begin_verse
  cargo test -- --test-threads=1
  cargo test -- --show-output
  cargo test <test_function_name>
  cargo test <sub_string_of_test_names_including_module_names_plus_function_names>
  cargo test -- --ignored
  cargo test --test <integration_test's crate_name or function_name>
#+end_verse

  In the *<proj_root>/tests/* directory, Cargo will compile each of the files as
  an individual crate.

  Files in subdirectories of the tests directory donâ€™t get compiled as separate
  crates or have sections in the test output.

  Common test files must be put in subdirectories, each directory represents a
  module.  For example, to use "common" module, put the code for common module
  in *<proj_root>/tests/common/mod.rs*.  If we rename mod.rs to other name,
  Cargo won't be able to find the module definition, because there is no
  *<proj_root>/tests/common.rs* as a guide.
* rustc
#+begin_verse
  rustc --explain E0308
#+end_verse
* THOUGHTS
** Don't abuse variable shadowing.
#+begin_quote
  This feature is often used in situations in which you want to convert a value
  from one type to another type.  Shadowing lets us reuse the 'guess' variable
  name rahter than forcing us to create two unique variables, such as
  'guess_str' and 'guess' for example.
#+end_quote
  However, it makes people hard to find its definition.  Let's see if tools can
  help find the accurate definition in one go.
** Don't use the "return value" of an operation.
#+begin_src rust
  let mut y = 5;
  let x = (y = 6);		// x has the value '()', not '6'
#+end_src
  This feature is to make sure that every expression to have a value, including
  the assignment operation/expression.

  The fundamental design fault is that they use an empty tuple to denote a void
  type.

  Rust allows you to propogate a meaningless return type of an statement like
  expression.  If this kind of error is not caught and is propogated to other
  places, it will be difficult to find the root cause, and this issue may cause
  runtime errors or type checking errors.

  The same design fault lives in JavaScript and PHP where the meaningless
  "undefined" is spreaded over the whole program.
** A good example of the use of enum type (union type) to enfoce exception handling
#+begin_verse
   Compiling guessing-game v0.1.0 (/Users/rduan/mygitlab/study-rust/guessing-game)
error[E0308]: mismatched types
  --> src/main.rs:20:22
   |
20 |     let guess: u32 = guess.trim().parse();//.expect("Please type a number!");
   |                ---   ^^^^^^^^^^^^^^^^^^^^ expected `u32`, found enum `Result`
   |                |
   |                expected due to this
   |
   = note: expected type `u32`
              found enum `Result<_, _>`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `guessing-game`

To learn more, run the command again with --verbose.
#+end_verse
* Print type of a variable
#+begin_src rust
  fn print_type_of<T>(_: &T) {
      println!("{}", std::any::type_name::<T>())
  }
#+end_src
* &[String], &Vec<String> and [String; 5]
  [String; 5] is a primitive array type.
  &[String] is a slice, it can be a slice of a vector or an array, etc.
  &Vec<String> is a reference of Vec<String>.
* Reasons to adopt Rust in our projects
  - advanced tool to aid us to design and code
    - type safety
      - no the billion-dollar bug (null bug)
      - safer error handling than Go and other nullable language, compiler can
        aid us and protect us
    - easy concurrency and reasoning (human understanding) by declarative
      computing
      - immutable variable by default
      - support closure which facilitates functional programming paradigm
    - modern built-in types and types from the standard library (using old
      languages, we have to tweak the old types for good practices nowadays)
  - prototyping and enough optimization in one go, compared to quick
    prototyping and hard and long optimization in Python
  - save cloud cost by
    - extremely high runtime speed (can serve more requests per second)
      comparable to C/C++
    - small memory footprints
    - small container images
  - modern tooling
    - very helpful compiler
    - specialized build system included (i.e. cargo) vs. C++'s GNU Make
    - documentation tools (e.g. rustup doc)
  - expressive and concise
    - less boilerplate code than Java and C++
    - more expressive and elegant than Go
      - support Generic
	- consider a use case where we need to sort entries of a user defined
          type, Go's implementation is tedious
	- In Go, people tend to abuse interface{} to hold unknown type of data,
          which bypasses the type safety checking
      - better trade-off than Go
        - Go hard-codes hash table into the language, whereas Rust uses library
  - modern package and module management
  - good community
    - strong language developers
    - friendly and supportive
    - backing by large companies (Mozilla, Microsoft, Amazon, Google, etc.)
  - better FFI than Go
* Cons compared to Python
  - no REPL
  - harder to learn
  - burden to manipulate the object memory ownership
  - less mature in the ecosystem
  - a little less coding speed
* Cons compared to Swift
  - no REPL
  - syntax being more elaborate
* Cons compared to C++
  - less mature in the ecosystem
* Cons compared to Java 8
  - less mature in the ecosystem
* Cons compared to Go
  - less mature in the ecosystem
  - harder to learn
* Cons compared to Common Lisp
  - no REPL
  - no meta programming control in the compile time and load time
  - not "data as code" and "code as data"
* Compare with Oz
** pros
   - much better string type
   - better runtime performance
   - smaller memory footprint, e.g. functions don't capture context variables
** cons
   - no tail call optimization which leads to a crippled support for recursion,
     which leads to less descriptive programming paradigm.
   - no difference list
   - conceptually more complicated types for pattern matching.  In Oz, Record
     type suffices.
   - quirks due to the expression-based design
     I like Oz's design better: procedure and functions are different types.
     e.g.
     - operations return an empty tuple
     - placing a semicolon turns an expression to a statement
   - functions are not closures, so the functional programming is limited
   - due to lack of GC, closures are complicated: it either borrows or moves
     captured values
* Compared with Swift
https://dev.to/rhymu8354/swift-vs-rust-an-overview-of-swift-from-a-rusty-perspective-18c7
* It is a design error to use an empty tuple to denote the Void type
  I like the Oz's design: an operation does not return anything.
* ANSI colors
#+begin_src rust
  const ANSI_BLACK: &str = "\x1b[0;30m";
  const ANSI_RED: &str = "\x1b[0;31m";
  const ANSI_GREEN: &str = "\x1b[0;32m";
  const ANSI_YELLOW: &str = "\x1b[0;33m";
  const ANSI_BLUE: &str = "\x1b[0;34m";
  const ANSI_MAGENTA: &str = "\x1b[0;35m";
  const ANSI_CYAN: &str = "\x1b[0;36m";
  const ANSI_WHITE: &str = "\x1b[0;37m";
  const ANSI_RESET: &str = "\x1b[0m";
#+end_src
* idioms
** open file and read to string
The following four versions are equivalent.

#+begin_src rust
  use std::fs;
  use std::io;

  fn read_username_from_file() -> Result<String, io::Error> {
      fs::read_to_string("hello.txt")
  }
#+end_src

#+begin_src rust
  use std::fs::File;
  use std:io;
  use std::io::Read;

  fn read_username_from_file() -> Result<String, io::Error> {
      let mut s = String::new();
      File::open("hello.txt")?.read_to_string(&mut s)?;
      Ok(s)
  }
#+end_src

#+begin_src rust
  use std::fs::File;
  use std::io;
  use std::io::Read;

  fn read_username_from_file() -> Result<String, io::Error> {
      let mut f = File::open("hello.txt")?;
      let mut s = String::new();
      f.read_to_string(&mut s)?;
      Ok(s)
  }
#+end_src

#+begin_src rust
  use std::fs::File;
  use std::io;
  use std::io::Read;

  fn read_username_from_file() -> Result<String, io::Error> {
      let f = File::open("hello.txt");

      let mut f = match f {
	  Ok(file) => file,
	  Err(e) => return Err(e),
      };

      let mut s = String::new();

      match f.read_to_string(&mut s) {
	  Ok(_) => Ok(s),
	  Err(e) => Err(e),
      }
  }
#+end_src
** return Ok(()) to indicate that the call is for its side effects only
** how to specify the Fn trait bounds
   Most of the time when specifying one of the Fn trait bounds, you can start
   with Fn and the compiler will tell you if you need FnMut or FnOnce based on
   what happens in the closure body.
* Cautions
** std::process::exit()
   https://doc.rust-lang.org/std/process/fn.exit.html
   [[https://users.rust-lang.org/t/is-rust-cleaning-up-after-exit/9613][Is Rust Cleaning Up After Exit]]
** str::to_lowercase is not 100% accurate
From the Rust book:
#+begin_quote
While to_lowercase will handle basic Unicode, it won't be 100% accurate.  If we
were writing a real application, we'd want to do a bit more work here.
#+end_quote
